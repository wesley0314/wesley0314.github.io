[{"title":"FFMPEG 缓冲设置","url":"/post/42e00536.html","content":"## **问题描述**\nGE11的视频说明书开发过程中遇到一个问题，网络带宽远低于视频码率时使用IjkPlayer播放会频繁缓冲再播放，影响使用体验。\n\n## **问题复现**\n先是想办法复现问题，为了可以控制网络速度，使用了Throttly - Network Tools这个软件来通过本地VPN限速的方式来模拟低带宽环境。视频源可以直接使用ijkPlayer自带demo里的sample。\n\n实际试下来会发生缓冲-播放频繁切换的现象，较为影响使用体验。\n\n## **问题解决**\n视频码率和网络环境没有改善可能的情况下，只能从缓冲策略下手，来改善使用体验。\n网上搜索了一下，其他的很多都是加快起播速度（所谓秒开）的设置方案，无帮助，最终在ijkPlayer的GitHub里找到了有人提出的类似问题，但最终没有答案。\n\n但题主提到的几个option还是给了很重要的线索，顺藤摸瓜找到了这篇日志，日志详细解释了ijkPlayer的缓冲策略和可以调整的几个option。大致摘抄如下：\n\n>buffering机制描述\n在read_thread的for(;;)循环中首帧未播放时每50ms/首帧播放后每500ms进行检查是否可以恢复播放；\n当检查到能满足播放时，就升级时间梯度，进行更严格的检查，让队列中缓存尽可能多的数据，以避免卡顿；同样，当触发卡顿时，也必须得等到满足时间梯度才能进入播放。\n在解码前取包时，若发现取不到包了，则暂停播放，触发缓冲，并置is->paused为1；此时依然要等循环调用ffp_check_buffering_l，填满队列，满足播放条件后才能恢复播放状态；是以牺牲延迟来保障流畅。\n满足播放条件：能播放时长已经足够播放hwm_in_ms了 或者 能播放的数据量已经大于256K了 \n*（这里我看实际代码是不准确的，对应看下面代码块第60行，我在ijkPlayer的源码里没找到，估计后来改了？）*\n时间梯度默认初始值\n``` java\nhigh_water_mark_in_bytes = DEFAULT_HIGH_WATER_MARK_IN_BYTES; 256K，始终不变\nfirst_high_water_mark_in_ms = DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS; 100\nnext_high_water_mark_in_ms = DEFAULT_NEXT_HIGH_WATER_MARK_IN_MS; 1000\nlast_high_water_mark_in_ms = DEFAULT_LAST_HIGH_WATER_MARK_IN_MS; 5000\ncurrent_high_water_mark_in_ms = DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS; 100\n```\n>buffer缓冲时长\n100ms -> 1s -> 2s -> 4s -> 5s，最大递增到5s；但满足256K即可放行；\n代码如下：\n``` java\nstatic int read_thread(void *arg) {\n    for  (;;) {\n        /*\n         * 开启缓冲机制\n         * 在for循环中，每读到一个包，都会检查是否进行缓冲\n         */\n\t    if (ffp->packet_buffering) {\n            io_tick_counter = SDL_GetTickHR();\n \n            if ((!ffp->first_video_frame_rendered && is->video_st) ||\n                (!ffp->first_audio_frame_rendered && is->audio_st)) {\n                // 首帧未显示前，50ms检测一次\n                if (abs((int) (io_tick_counter - prev_io_tick_counter)) > FAST_BUFFERING_CHECK_PER_MILLISECONDS) {\n                    prev_io_tick_counter = io_tick_counter;\n                    ffp->dcc.current_high_water_mark_in_ms = ffp->dcc.first_high_water_mark_in_ms;\n                    ffp_check_buffering_l(ffp);\n                }\n            } else {\n                if (abs((int) (io_tick_counter - prev_io_tick_counter)) > BUFFERING_CHECK_PER_MILLISECONDS) {\n                \t// 首帧显示后，500ms检测一次\n                    prev_io_tick_counter = io_tick_counter;\n                    ffp_check_buffering_l(ffp);\n                }\n            }\n        }      \n    }\n}\n \n/*\n  * 循环检查是否缓冲够了，够了就去播放吧，取消缓冲状态，取消暂停，恢复播放\n  */\nvoid ffp_check_buffering_l(FFPlayer *ffp) {\n    // 阶梯递增，最大DEFAULT_LAST_HIGH_WATER_MARK_IN_MS，5s\n    int hwm_in_ms = ffp->dcc.current_high_water_mark_in_ms;\n    int hwm_in_bytes = ffp->dcc.high_water_mark_in_bytes;\n \n    // 队列里缓存的能播放的音视频播放时长\n    int64_t audio_cached_duration = ffp->stat.audio_cache.duration;\n    int64_t video_cached_duration = ffp->stat.video_cache.duration;\n    int cached_duration_in_ms = min((video_cached_duration, audio_cached_duration);\n    \n    /*\n      *  计算当前能播放的时长超过了多少hwm_in_ms\n      *  我理解这块是个四舍五入，然后放大一百倍，cached_duration_in_ms * 100.5 / hwm_in_ms\n      *  后面的算法，实际上表示cached_duration_in_ms>hwm_in_ms即可进行播放了\n      */\n    int  buf_time_percent = (int) av_rescale(cached_duration_in_ms, 1005, hwm_in_ms * 10);\n \n    // 队列里缓存的音视频总大小\n    int cached_size = is->audioq.size + is->videoq.size;\n    // 计算缓存数据大小超过了多少hwm_in_bytes\n    int buf_size_percent = (int) av_rescale(cached_size, 1005, hwm_in_bytes * 10);\n \n    /*\n      *  能播放时长已经足够播放hwm_in_ms了  ||\n      *  能播放的数据量已经足够播放hwm_in_bytes了，\n      *  就解除缓冲状态/暂停状态，设置为播放状态\n      */ \n    int need_start_buffering = 0;\n    if  (buf_time_percent >= 100 || buf_size_percent >= 100) {\n        need_start_buffering = 1;\n    }\n \n    if (need_start_buffering) {\n        if (hwm_in_ms < ffp->dcc.next_high_water_mark_in_ms) {\n            hwm_in_ms = ffp->dcc.next_high_water_mark_in_ms;\n        } else {\n            hwm_in_ms *= 2;\n        }\n \n        if (hwm_in_ms > ffp->dcc.last_high_water_mark_in_ms)\n            hwm_in_ms = ffp->dcc.last_high_water_mark_in_ms;\n \n        ffp->dcc.current_high_water_mark_in_ms = hwm_in_ms;\n \n        if (is->buffer_indicator_queue && is->buffer_indicator_queue->nb_packets > 0) {\n            if ((is->audioq.nb_packets >= MIN_MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)\n                && (is->videoq.nb_packets >= MIN_MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request)) {\n                // 音视频队列的缓冲区差不多了，> MIN_MIN，则去除暂停状态，\n                ffp_toggle_buffering(ffp, 0);\n            }\n        }\n    }\n}\n \nvoid ffp_toggle_buffering(FFPlayer *ffp, int start_buffering) {\n    SDL_LockMutex(ffp->is->play_mutex);\n    ffp_toggle_buffering_l(ffp, start_buffering);\n    SDL_UnlockMutex(ffp->is->play_mutex);\n}\n \nvoid ffp_toggle_buffering_l(FFPlayer *ffp, int buffering_on) {\n    if (!ffp->packet_buffering) {\n        // 缓存机制是否开启\n        return;\n    }\n \n    VideoState *is = ffp->is;\n    if (buffering_on && !is->buffering_on) {\n        // 当前没buffering, 要去buffering，FFP_MSG_BUFFERING_START\n        is->buffering_on = 1;\n        stream_update_pause_l(ffp); // 暂停\n    } else if (!buffering_on && is->buffering_on) {\n        // 当前buffering，取消buffering，FFP_MSG_BUFFERING_END\n        is->buffering_on = 0;\n        stream_update_pause_l(ffp); // 取消暂停\n    }\n}\n \n \n/*\n  * 软件音频、软硬解视频时，阻塞等待直到退出或者有AVPacket数据\n  * 在开启缓冲机制的情况下，会暂停进行缓冲，等待check buffering修复到播放状态\n  */\nstatic int packet_queue_get_or_buffering(FFPlayer *ffp, PacketQueue *q, AVPacket *pkt, int *serial,\n                                         int *finished) {\n    assert(finished);\n    if (!ffp->packet_buffering){\n        // 未开启缓冲机制\n        return packet_queue_get(q, pkt, 1, serial); // queue为空时会阻塞等待\n    }\n \n    while (1) {\n        int new_packet = packet_queue_get(q, pkt, 0, serial);\n        if (new_packet < 0) {\n            return -1;\n        } else if (new_packet == 0) {\n            if (q->is_buffer_indicator && !*finished) {\n                ffp_toggle_buffering(ffp, 1);   // 暂停当前，去缓冲，设置为1\n            }\n            new_packet = packet_queue_get(q, pkt, 1, serial); // 缓冲了，再拿一次\n            if (new_packet < 0) {\n                return -1;\n            }\n        }\n \n        if (*finished == *serial) {\n            av_packet_unref(pkt);\n            continue;\n        } else {\n            break;\n        }\n    }\n \n    return 1;\n}\n```\n实际我在ijkPlayer的代码里看到对于缓冲时长和缓冲数据量的处理是这样的，如果缓冲时长设置有效，缓冲时长的percent优先，否则以数据量缓冲进度为准：\n![](https://s2.loli.net/2023/03/23/M5ub6cgqF8wElLj.png)\n于是我在demo里添加了如下的修改\n```java\nijkMediaPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_PLAYER, \"next-high-water-mark-ms\", 10 * 1000L);\n```\n但无效，并且log显示设置option失败\n``` shell\nError setting option next-high-water-mark-ms to value 10000.\n```\n又进行了一番[搜索](https://blog.csdn.net/silently_frog/article/details/108617063)之后，看到这么一篇博客，解释了ijkPlayer设置option时一些限制：\n``` java\n{ \"max-buffer-size\",                    \"max buffer size should be pre-read\",\n OPTION_OFFSET(dcc.max_buffer_size), OPTION_INT(MAX_QUEUE_SIZE, 0, MAX_QUEUE_SIZE) }\n```\n>配置一个选项需要填写4个信息：\nmax-buffer-size：选项的名称；\nmax buffer size should be pre-read：选项的描述；\nOPTION_OFFSET(dcc.max_buffer_size)：选项对应的系统变量；\nOPTION_INT(MAX_QUEUE_SIZE, 0, MAX_QUEUE_SIZE)：选项的取值范围；\n下面解释OPTION_OFFSET、OPTION_INT函数：\nOPTION_OFFSET：\n``` java\n#define OPTION_OFFSET(x) offsetof(FFPlayer, x)\n```\n>系统最终回调用offsetof函数，这个是gcc中的函数，网上搜了下，其作用为：访问返回结构体FFPlayer中成员变量x相对于结构体首地址的偏移量，转换为Java的思维就是返回FFPlayer类中成员变量x.\nOPTION_INT:\n``` c++\n#define OPTION_INT(default__, min__, max__) \\\n    .type = AV_OPT_TYPE_INT, \\\n    { .i64 = default__ }, \\\n    .min = min__, \\\n    .max = max__, \\\n    .flags = AV_OPT_FLAG_DECODING_PARAM\n```\n>其第一个参数为选项的默认值，第二个参数为选项的最小值，第三个参数为选项的最大值\n\n**再看我们设置的option相关代码，发现它的最大最小值是写死的 DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS 到 DEFAULT_LAST_HIGH_WATER_MARK_IN_MS之间**\n``` java\n{ \"first-high-water-mark-ms\",           \"first chance to wakeup read_thread\",\n OPTION_OFFSET(dcc.first_high_water_mark_in_ms),\n OPTION_INT(DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS,\n            DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS,\n            DEFAULT_LAST_HIGH_WATER_MARK_IN_MS) },\n{ \"next-high-water-mark-ms\",            \"second chance to wakeup read_thread\",\n OPTION_OFFSET(dcc.next_high_water_mark_in_ms),\n OPTION_INT(DEFAULT_NEXT_HIGH_WATER_MARK_IN_MS,\n            DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS,\n            DEFAULT_LAST_HIGH_WATER_MARK_IN_MS) },\n{ \"last-high-water-mark-ms\",            \"last chance to wakeup read_thread\",\n OPTION_OFFSET(dcc.last_high_water_mark_in_ms),\n OPTION_INT(DEFAULT_LAST_HIGH_WATER_MARK_IN_MS,\n            DEFAULT_FIRST_HIGH_WATER_MARK_IN_MS,\n            DEFAULT_LAST_HIGH_WATER_MARK_IN_MS) },\n```\nDEFAULT_FIRST_HIGH_WATER_MARK_IN_MS = 100ms\nDEFAULT_LAST_HIGH_WATER_MARK_IN_MS = 5000ms\n我设置的是10000ms自然会报错，改为5000ms后不再报错且生效。\n为什么会有上述限制还要进一步的寻找答案，目前猜和代码的逻辑有关系。","tags":["Android","FFMPEG","MultiMedia","IjkPlayer"],"categories":["学习笔记"]},{"title":"Maven依赖自动更新问题研究","url":"/post/ca157723.html","content":"## 1. 问题描述\n之前在GE11项目中，APP的公共依赖从公司self-hosted的Nexus maven仓库中拉取，而依赖更新发布则是使用Gradle的maven_publish插件配合自定义脚本推送到上述仓库。\n实际开发中我们遇到了一个问题，依赖有更新时只会刷新maven仓库中的制品，此时APP重新编译并不会从maven拉取最新的依赖而是直接使用本地缓存。这在项目开发初期引发了很多问题，显著阻碍了开发的进度。\n## 2. 临时方案\n在项目中后期，因为第一时间没有找到较好的解决方案且项目工期太紧，每个开发都被逼学会了编译前先删除gradle cache的hack solution，显然这样虽然解决了问题，但既耗时又不可靠。一定存在一个更合理更优雅的解决方案。\n## 3. 研究重启\n现在GE11项目第一阶段已经接近尾声，我在继续开发核心库时需要升级版本，但觉得应该使用SNAPSHOT机制来发布。简单搜索到这个[理解Maven中的SNAPSHOT版本和正式版本-阿里云开发者社区](https://developer.aliyun.com/article/307112)\n其中这段话勾起了我之前的痛苦回忆，想起来之前悬而未决的问题：\n![](https://s2.loli.net/2023/03/23/v4MxwBqYXCPjlWQ.png)\n## 4. 本地模拟和问题解决\n为了能更好的还原我们的开发环境，在机器上自己搭建了一个nexus来做模拟验证，同时继续疯狂Google和看gradle以及maven的文档来寻找答案。\nMaven和Gradle是两个不同的构建系统，上述图片里的xml片段是项目使用maven构建时配置用的，不能用于我们开发 Android APP 使用的 Gradle。\n在尝试的过程中，我发现nexus部署后默认会创建几个repo，其中就有`maven-snapshots`\n![](https://s2.loli.net/2023/03/23/Ewu4Wxb6YZrRqoA.png)\n同时Gradle文档里对snapshot相关的介绍，表示正常如果需要发布snapshot版本，要发布到单独的snapshots仓库：\n![](https://s2.loli.net/2023/03/23/X34WYTwcpMNdUGk.png)\n于是我修改已有的发布脚本，通过判断版本名是否以`SNAPSHOT`结尾来确定发布到maven的仓库类型\n![](https://s2.loli.net/2023/03/23/oqmfuCT5gwUpcEd.png)\n实验之后发现snapshots仓库可以保存所有历史发布过的同版本依赖：\n![](https://s2.loli.net/2023/03/23/jcMxvHpuka9AiQg.png)\n那么剩下的问题就是如何保证Gradle每次构建时自动拉取最新的依赖，有人在StackOverflow上提出了类似的[问题](https://stackoverflow.com/questions/42058626/how-to-get-newest-snapshot-of-a-dependency-without-changing-version-in-gradle)\n只需要在项目的build.gradle中添加下面的配置，每次编译gradle就会拉取snapshot版本或标记了`changing = true`的依赖的最新版本。\n``` groovy\nconfigurations.all {\n        resolutionStrategy.cacheChangingModulesFor 0, 'seconds'\n    }\n```\n原因是Gradle默认保存changing的依赖24小时，需要使用这个配置来改为0秒，下面的回答还提到了Gradle 6+以后snapshot依赖默认`changing=true`（[相关链接](https://stackoverflow.com/questions/32652738/how-can-i-force-update-all-the-snapshot-gradle-dependencies-in-intellij)）\n![](https://s2.loli.net/2023/03/23/LEGsKhIMCbZJ7gD.png)\n至此问题解决，交叉验证通过。\n\n记得之前有尝试过在依赖后面添加 `changing = true`，无效的原因现在也找到了。然而，随后我在项目的`deps.gradle`里发现了这个片段，`cacheChangingModulesFor`被设置为了12小时……\n![](https://s2.loli.net/2023/03/23/SBEgzif6KqbyNsp.png)\n需要补充的是，第二个配置`cacheDynamicVersionsFor`是对动态版本依赖的缓存策略配置，例如`xxx:1.0+`或者`xxx:latest`。具体可以看官方文档：\n[文档1](https://pateo.feishu.cn/docx/ZGqmdZQi5oKHvkxdfGAcyVufnqh#XOS6dScyAoE4s2xOkhrcDcvpnjf)\n[文档2](https://pateo.feishu.cn/docx/ZGqmdZQi5oKHvkxdfGAcyVufnqh#UOYwd88Ioo6eqexW63Rci0ggnVe)\n## 5. releases仓库部署策略\n值得一提的是，在用本地nexus测试的时候，我发现默认release仓库是不允许相同的版本反复修改的，如果不在后台将repo默认的部署策略配置改为Allow redeploy，我们publish是会失败的。\n![](https://s2.loli.net/2023/03/23/3fP4l8QFEYOyT1u.png)\n报错如下：\n``` shell\nExecution failed for task ':library-core:publishReleasePublicationToMavenRepository'.\n> Failed to publish publication 'release' to repository 'maven'\n   > Could not PUT 'http://127.0.0.1:8081/repository/maven-releases/com/pateo/app/corelib/PateoPlayerAndSessionMgr/android/PlayerAndSessionMgr_Player/1.0.0/PlayerAndSessionMgr_Player-1.0.0.jar'. \n    Received status code 400 from server: Repository does not allow updating assets: maven-releases\n```\n## 6. 结论\n1. 在开发过程中应该使用 snapshots 库，稳定后发布到 releases 库，保证开发时敏捷，发布后稳定。\n2. 使用Gradle构建时为了保证取用最新snapshot版本，需要修改`cacheChangingModulesFor`为较小数值\n3. releases库的部署策略不应该启用允许重复部署，确保版本稳定\n4. 在向制品库发布正式版本时，最好同时打Git TAG，确保可追溯（可以整合进发布脚本来实现自动化）","tags":["Android","Maven","Gradle"],"categories":["学习笔记"]},{"title":"openWrt squashfs 固件扩容","url":"/post/a83d6f84.html","content":"可以参考eSir的YouTube视频：\n\nhttps://www.youtube.com/watch?v=YwbwzuXKNlg\n\nlsblk 查看分区 sda1是固件 sda2是默认系统分区 overlay挂载在looper上\n\n用cfdisk新建sda3分区，指定较大的空间（方向键上下选择分区，左右选择操作，选择free space，new，指定大小，write，quit）\n\nmkfs.ext4 格式化刚刚创建的分区\n\n将/dev/sda3挂载到/mnt/sda3目录\n\n拷贝/overlay 目录下所有内容到/mnt/sda3下面，cp -r /overlay/* /mnt/sda3/\n\n进入lede-luci webUI的系统-挂载点，新建挂载点，启用，选择/mnt/sda3 挂载到额外的/overlay，保存并应用\n\n重启软路由","categories":["折腾笔记"]},{"title":"openWrt的物理安装方法","url":"/post/66afd8af.html","content":"1. 下载固件（如[eSir的](https://drive.google.com/drive/folders/1uRXg_krKHPrQneI3F2GNcSVRoCgkqESr)），如果是压缩格式如tar，解压出img文件\n2. 用Ventoy+U盘+WinPE做一个PE U盘 \na. 下载 [Ventoy](https://www.ventoy.net/cn/download.html)，并安装到U盘\nb. 下载 [WePE64 ISO](https://www.wepe.com.cn/download.html)\nc. 下载 physdiskwrite.exe ，将WePE64的ISO以及physdiskwrite.exe都放到U盘根目录\n3. 软路由断电，插入U盘，插入键盘，软路由接显示器\n4. 启动软路由，键盘按F10/F12/F11/Delete 键，进入启动选择，选WinPE启动\n5. 进入WinPE系统后打开CMD，定位到U盘根目录，使用以下命令刷写镜像\n``` bash\nphysdiskwrite.exe -u xxx.img\n```\n根据命令行提示，输入数字选择刷写目标\n6. 刷写完成后重启软路由\n7. 重启后记得在进系统前拔掉U盘，启动成功后电脑网线连eth0口，192.168.5.1进入WebUI\n8. 重设密码以后，一定记得修改网口物理设置，然后HDCP，上网账号等等等……","categories":["折腾笔记"]},{"title":"DDNSTO openWrt 插件安装方法","url":"/post/b1e7b70f.html","content":"OpenWrt固件开发者众多，部分固件不自带ddnsto，可通过以下任一脚本轻松安装：\nvia curl\n``` bash\nsh -c \"$(curl -sSL http://fw.koolcenter.com/binary/ddnsto/openwrt/install_ddnsto.sh)\"\n```\nvia wget\n``` bash\nsh -c \"$(wget --no-check-certificate -qO- http://fw.koolcenter.com/binary/ddnsto/openwrt/install_ddnsto.sh)\"\n```\nothers\n``` bash\ncd /tmp; wget --no-check-certificate http://fw.koolcenter.com/binary/ddnsto/openwrt/install_ddnsto.sh; sh ./install_ddnsto.sh\n```\n在OpenWrt TTYD终端中输入任一上述命令，会自动安装完成。\n![](https://s2.loli.net/2023/03/23/fhQrU4evJ6HCPko.png)\n![](https://s2.loli.net/2023/03/23/aoYJEZePR6SIn7h.png)\n或者putty、MobaXterm等软件登陆SSH，输入任一上述命令，会自动安装完成。\n![](https://s2.loli.net/2023/03/23/4knjo5PEf9IAgTt.png)\n![](https://s2.loli.net/2023/03/23/KqkTmlw2B79ezxb.png)\n![](https://s2.loli.net/2023/03/23/8RHaOkpYI4GD3bl.png)\n然后找到DDNS.to内网穿透，启用并设置token。\n![](https://s2.loli.net/2023/03/23/QSo1q2VihPpeYrI.png)","categories":["折腾笔记"]},{"title":"Docker版为知笔记遇到的问题","url":"/post/6c8b8a9f.html","content":"今天在自家的Nas上部署了docker版为知笔记，浏览器无法正常上传图片，Mac和Linux上的WizNoteX客户端无法正常同步笔记和新建笔记，iOS版的却是正常的。\n后来研究了一下，发现是因为新版的WizNoteX不兼容，重新下载安装旧版的为知笔记后Mac和Linux端app又遇到了登陆失败的问题，后来研究发现是需要填入Http地址，切换到DDNSTO提供的http端口后终于登陆成功。\nLinux端登陆成功后又发现无法切换输入法，也就是说无法输入中文，google之后发现是因为不支持fcitx，需要自行编译十分麻烦。\n然后换了非官方的[WiznotePlus](https://github.com/altairwei/WizNotePlus)后解决了问题。正在犹豫要不要Mac上也改用这个。\n![Linux上的WizNotePlus](https://s2.loli.net/2023/03/23/rS7o3PygAUEOaFN.png)\nUpdate：Mac版的WizNotePlus无法打开，提示无法验证开发者。换回了原版。","categories":["折腾笔记"]}]